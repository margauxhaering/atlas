<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>HDD vs LDD Experiment</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <link href="css/main.css" rel="stylesheet">
</head>
<body>
  <div id="topMenu">
    <h1><a href="index.html">HDD vs LDD Atlas</a></h1>
    <div id="menuButtons">
      <button><a href="index.html">Home</a></button>
      <button><a href="pca.html">PCA</a></button>
      <button><a href="explore.html">Explore annotation</a></button>
    </div>
  </div>

  <div id="mainContainer">
    <div id="infoPanel">
      <h2>3D PCA</h2>
      <p>
        This 3D scatter plot shows PCA components (PC1, PC2, PC3).
        Drag the plot to rotate and explore clusters in 3D.
      </p>

    <div class="legend">
      <strong>Groups : </strong><br><br>
      <div class="legend-item">
        <div class="legend-color" style="background:#F5AB42;"></div> LDD light
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background:#F56342;"></div> LDD dark
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background:#ACE3E8;"></div> HDD light
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background:#3797ED;"></div> HDD dark
      </div>
      <br><br><strong>Variance : </strong>
    <br><br>  PC1 : 72.1% <br> PC2 : 5.5% <br> PC3 : 4%

    </div>
  </div>

  <div id="pcaContainer">
    <svg id="pcaPlot"></svg>
  </div>

  <script>

    const data = [{point:"darkHDD_rep1",group:"darkHDD",pc1:-113.0211,pc2:35.7374,pc3:3.966},
                  {point:"darkHDD_rep2",group:"darkHDD",pc1:-131.7889,pc2:56.2568,pc3:13.9377},
                  {point:"darkHDD_rep3",group:"darkHDD",pc1:-126.1346,pc2:40.7047,pc3:38.1559},
                  {point:"darkHDD_rep4",group:"darkHDD",pc1:-99.566,pc2:26.1834,pc3:-6.7535},
                  {point:"lightHDD_rep1",group:"lightHDD",pc1:-116.5401,pc2:-21.6787,pc3:-6.7237},
                  {point:"lightHDD_rep2",group:"lightHDD",pc1:-108.7635,pc2:-30.8598,pc3:-13.5297},
                  {point:"lightHDD_rep3",group:"lightHDD",pc1:-111.3888,pc2:-26.0227,pc3:3.4165},
                  {point:"lightHDD_rep4",group:"lightHDD",pc1:-120.7782,pc2:-34.3298,pc3:-34.8997},
                  {point:"lightHDD_rep5",group:"lightHDD",pc1:-124.9909,pc2:-43.4002,pc3:2.6519},
                  {point:"darkLDD_rep1",group:"darkLDD",pc1:114.1689,pc2:23.6028,pc3:-24.0371},
                  {point:"darkLDD_rep2",group:"darkLDD",pc1:88.0904,pc2:25.7013,pc3:-46.7101},
                  {point:"darkLDD_rep3",group:"darkLDD",pc1:95.6159,pc2:19.3757,pc3:-24.5827},
                  {point:"darkLDD_rep4",group:"darkLDD",pc1:133.2296,pc2:31.4895,pc3:45.353},
                  {point:"darkLDD_rep5",group:"darkLDD",pc1:112.0434,pc2:21.626,pc3:-36.9579},
                  {point:"lightLDD_rep1",group:"lightLDD",pc1:104.4356,pc2:-25.5826,pc3:5.9797},
                  {point:"lightLDD_rep2",group:"lightLDD",pc1:118.8672,pc2:-22.6655,pc3:-11.329},
                  {point:"lightLDD_rep3",group:"lightLDD",pc1:101.9191,pc2:-21.4592,pc3:30.7769},
                  {point:"lightLDD_rep4",group:"lightLDD",pc1:99.2556,pc2:-26.4658,pc3:23.7356},
                  {point:"lightLDD_rep5",group:"lightLDD",pc1:85.3465,pc2:-28.2134,pc3:37.55}]


    const colorMap = {
      lightLDD: "#F5AB42",
      darkLDD: "#F56342",
      lightHDD: "#ACE3E8",
      darkHDD: "#3797ED"
    };


    const svg = d3.select("#pcaPlot");
    const width = document.getElementById("pcaContainer").clientWidth;
    const height = document.getElementById("pcaContainer").clientHeight;
    const g = svg.append("g").attr("transform", `translate(${width / 2}, ${height / 2})`);

    const scale = 250;
    const xExtent = d3.extent(data, d => d.pc1);
    const yExtent = d3.extent(data, d => d.pc2);
    const zExtent = d3.extent(data, d => d.pc3);

    const xScale = d3.scaleLinear().domain(xExtent).range([-scale, scale]);
    const yScale = d3.scaleLinear().domain(yExtent).range([-scale, scale]);
    const zScale = d3.scaleLinear().domain(zExtent).range([-scale, scale]);

    let angleX = 0, angleY = 0;

    function project(x, y, z) {
      const cosY = Math.cos(angleY), sinY = Math.sin(angleY);
      const cosX = Math.cos(angleX), sinX = Math.sin(angleX);
      const x1 = cosY * x + sinY * z;
      const z1 = -sinY * x + cosY * z;
      const y1 = cosX * y - sinX * z1;
      const depth = (z1 + scale) / (2 * scale);
      return { x: x1, y: y1, depth };
    }

    const gridLines = [];
    const gridSteps = 5;
    const range = d3.range(-scale, scale + 1, (2 * scale) / gridSteps);
    range.forEach(x => range.forEach(z => gridLines.push([[x, -scale, z], [x, scale, z]])));
    range.forEach(y => range.forEach(z => gridLines.push([[-scale, y, z], [scale, y, z]])));
    range.forEach(x => range.forEach(y => gridLines.push([[x, y, -scale], [x, y, scale]])));

    const axes = [
      { start: [0, 0, 0], end: [scale, 0, 0], label: "PC1", color: "#000" },
      { start: [0, 0, 0], end: [0, scale, 0], label: "PC2", color: "#000" },
      { start: [0, 0, 0], end: [0, 0, scale], label: "PC3", color: "#000" }
    ];

    function render() {
      const grid = g.selectAll(".grid-line").data(gridLines);
      grid.enter().append("line")
        .attr("class", "grid-line")
        .attr("stroke", "#ccc")
        .attr("stroke-width", 0.5)
        .merge(grid)
        .attr("x1", d => project(...d[0]).x)
        .attr("y1", d => project(...d[0]).y)
        .attr("x2", d => project(...d[1]).x)
        .attr("y2", d => project(...d[1]).y)
        .attr("opacity", d => 0.2 + 0.5 * project(...d[0]).depth);

      const axisLines = g.selectAll(".axis-line").data(axes);
      axisLines.enter().append("line")
        .attr("class", "axis-line")
        .attr("stroke-width", 2)
        .merge(axisLines)
        .attr("stroke", d => d.color)
        .attr("x1", d => project(...d.start).x)
        .attr("y1", d => project(...d.start).y)
        .attr("x2", d => project(...d.end).x)
        .attr("y2", d => project(...d.end).y);

      const axisLabels = g.selectAll(".axis-label").data(axes);
      axisLabels.enter().append("text")
        .attr("class", "axis-label")
        .merge(axisLabels)
        .attr("x", d => project(...d.end).x + 5)
        .attr("y", d => project(...d.end).y - 5)
        .text(d => d.label);

      const points = g.selectAll("circle").data(data, d => d.point);
      points.enter().append("circle")
        .attr("r", 10)
        .attr("fill", d => colorMap[d.group] || "#888")
        .merge(points)
        .sort((a, b) => project(xScale(a.pc1), yScale(a.pc2), zScale(a.pc3)).depth -
                        project(xScale(b.pc1), yScale(b.pc2), zScale(b.pc3)).depth)
        .attr("cx", d => project(xScale(d.pc1), yScale(d.pc2), zScale(d.pc3)).x)
        .attr("cy", d => project(xScale(d.pc1), yScale(d.pc2), zScale(d.pc3)).y)
        .attr("opacity", d => 0.5 + 0.5 * project(xScale(d.pc1), yScale(d.pc2), zScale(d.pc3)).depth);
    }

    let dragging = false, lastX, lastY;
    svg.on("mousedown", (event) => { dragging = true; lastX = event.x; lastY = event.y; svg.style("cursor", "grabbing"); });
    svg.on("mouseup", () => { dragging = false; svg.style("cursor", "grab"); });
    svg.on("mousemove", (event) => {
      if (dragging) {
        const dx = event.x - lastX;
        const dy = event.y - lastY;
        angleY += dx * 0.01;
        angleX += dy * 0.01;
        lastX = event.x;
        lastY = event.y;
        render();
      }
    });

    render();
  </script>
</body>
</html>
